# CSS Specificity и каскад

## Вопросы
1. Как точно рассчитывается specificity в CSS? (формула, веса селекторов)
2. Приведи пример, где !important победит инлайн-стиль, и пример, где не победит.
3. Как ты решаешь проблемы с specificity в большом проекте (минимум 3 подхода/методологии)?

## Специфичность

Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу.
В вычислениях участвуют CSS-селекторы.
Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше.
Правило каскада «кто ниже, тот и выигрывает» при этом может нарушаться.

Специфичность — это одно из базовых понятий в CSS.

## Вес селекторов

Давайте разберёмся, как браузер взвешивает селектор. Ниже перечислены типы селекторов по убыванию специфичности:

1. Селекторы по идентификатору;
2. Селекторы по классу, селекторы по атрибуту и селекторы с псевдоклассами;
Селекторы по тегу, селекторы с псевдоэлементами.
3. Комбинаторы +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.

Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок.

Для наглядного представления веса селектора ему можно присвоить количество очков веса

Для идентификаторов это будет: **100**

Для селекторов по классу, по атрибуту и псевдоклассов: **10**

Для тега это будет: **1**


| Селектор                                                                | Очки веса                                 |
|-------------------------------------------------------------------------|-------------------------------------------|
| Inline-стиль (style="color: red;")                                      | 1000                                      |
| Идентификатор (#some)                                                   | 100                                       |
| Класс (.some), Атрибут ([type="text"]) и Псевдокласс (:hover)           | 10                                        |
| Селекторы типов элементов (div, p) и псевдоэлементы (::before, ::after) | 1                                         |
| Универсальный селектор (*) и комбинаторы (+, ~, >)                      | 0                                         |
| !important                                                              | Имеет наивысший приоритет, перекрывая все |


Пример расчета:

* body #header .title: (0, 1, 1, 1) = 100 + 10 + 1 = 111.
* body #header: (0, 1, 0, 1) = 100 + 1 = 101.
* p.content: (0, 0, 1, 1) = 10 + 1 = 11.
* a:hover: (0, 0, 1, 1) = 10 + 1 = 11.


## Правило каскада
Если два правила имеют одинаковую специфичность, применяется то, которое позднее в таблице стилей (ниже в коде или в более позднем файле CSS).
Если они и вовсе одинаковы, то применяется последнее правило, соответствующее элементу.


## Пример, где !important победит инлайн-стиль, и пример, где не победит.

### !important из css побеждает inline-стиль
```html
<!DOCTYPE html>
<html>
<head>
  <style>
    #myDiv {
      color: red !important;
    }
  </style>
</head>
<body>
  <div id="myDiv" style="color: blue;">Текст</div>
</body>
</html>
```

### !important из css не побеждает inline-стиль

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    #myDiv {
      color: red !important;
    }
  </style>
</head>
<body>
  <div id="myDiv" style="color: blue; !important;">Текст</div>
</body>
</html>
```
Казалось бы вот оно решение.  Но !important в inline-стилях не отработает таким образом, цвет остался красным. Однако его можно установить с помощью javascript


```html
<!DOCTYPE html>
<html>
<head>
  <style>
    #myDiv {
      color: red !important;
    }
  </style>
</head>
<body>
  <div id="myDiv">Текст</div>

  <script>
    // Устанавливаем инлайн-стиль с !important через JS
    document.getElementById('myDiv').style.setProperty('color', 'blue', 'important');
  </script>
</body>
</html>
```

Всё гуд. Цвет текста синий


## Как ты решаешь проблемы с specificity в большом проекте (минимум 3 подхода/методологии)?

1. Я стараюсь использовать методологию БЭМ. Её так-то одной уже достаточно, чтобы избежать многих проблем
2. Избегаю использования !important
3. В больших проектах есть отдельный сервис стилей, к которому обращаются все фронты, его подключаем первым. Если что-то нужно переопределить внутри отдельного фронта, то это легко сделать отдельно в этом фронте.


## Источники
[doka.guide](https://doka.guide/css/specificity/)
